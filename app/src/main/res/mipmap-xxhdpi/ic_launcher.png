package com.nanj.zjh.bath.app;

import android.util.Log;

import androidx.annotation.Nullable;
import androidx.collection.ArrayMap;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MediatorLiveData;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.Observer;

import com.example.x6.serial.GridListener;
import com.example.x6.serial.LockerService;
import com.lxl.jzh.base.Utils.NetWorkUtil;
import com.lxl.jzh.locker.LockServiceProvider;
import com.nanj.zjh.bath.annotation.OperationCode;
import com.nanj.zjh.bath.api.ApiResponse;
import com.nanj.zjh.bath.api.NetWork;
import com.nanj.zjh.bath.api.PayService;
import com.nanj.zjh.bath.database.LockDataBase;
import com.nanj.zjh.bath.entity.Cabinet;
import com.nanj.zjh.bath.entity.OperationRecord;
import com.nanj.zjh.bath.entity.PayRequest;
import com.nanj.zjh.bath.entity.PayResult;
import com.nanj.zjh.bath.entity.QrCodeInfoResult;
import com.nanj.zjh.bath.utils.Constant;
import com.nanj.zjh.bath.utils.SpeechHelper;
import com.nanj.zjh.bath.utils.UsbDeviceService;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static com.example.x6.serial.LockerConstant.CABINET_CLOSED;
import static com.example.x6.serial.LockerConstant.CABINET_OPENED;
import static com.xgzx.veinmanager.VeinApi.MSG_COLLECT_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_CONNECT_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_ID_REPEAT;
import static com.xgzx.veinmanager.VeinApi.MSG_INVALID_ID;
import static com.xgzx.veinmanager.VeinApi.MSG_NO_DEVICE;
import static com.xgzx.veinmanager.VeinApi.MSG_REGISTER_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_REGISTER_REPEAT;
import static com.xgzx.veinmanager.VeinApi.MSG_REGISTER_TIMEOUT;
import static com.xgzx.veinmanager.VeinApi.MSG_REQUEST_PERMISSION_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_VERTIFIY_FAIL;
import static com.xgzx.veinmanager.VeinApi.XG_ERR_NO_SAME_FINGER;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_BEEP1;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_BEEP2;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_PUTFINGER;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_PUTFINGER_AGAIN;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_VERIFY_FAIL;

public class HomeRepository {
    private static final String TAG = "HomeRepository";
    private LockerApp lockerApp;
    private PayService payService;
    private AppExecutors appExecutors;
    private LockDataBase dataBase;
    private UsbDeviceService usbDeviceService;
    private SpeechHelper speechHelper;
    private LockerService<Cabinet> lockerService;

    //    存储的时候获取可用的柜子
    private Cabinet availableCabinet;
    private OperationRecord operationRecord = OperationRecord.provide(Constant.ACTION_UNKNOWN);


    private AtomicBoolean started = new AtomicBoolean(false);

    public HomeRepository(AppExecutors appExecutors, LockDataBase dataBase) {
        lockerApp = LockerApp.get();
        this.appExecutors = appExecutors;
        this.dataBase = dataBase;

    }

    //    因为需要权限的处理 所以不能在构造函数中直接初始化
    public void start() {
        if (started.compareAndSet(false, true)) {

            lockerService = LockServiceProvider.get(gridListener, lockerApp);
            payService = NetWork.payService();

            speechHelper = new SpeechHelper(lockerApp);
            speechHelper.start();

            usbDeviceService = new UsbDeviceService(lockerApp, listener);
            usbDeviceService.connectVeinUsbDevice();
        }

    }

    private GridListener<Cabinet> gridListener = new GridListener<Cabinet>() {
        @Override
        public void updateStatus(Cabinet cabinet) {

        }
    };

    public void stop() {
        if (started.compareAndSet(true, false)) {
            speechHelper.release();
            speechHelper = null;

            usbDeviceService.close();
            usbDeviceService = null;
            lockerService.exit();
            lockerService = null;
        }
    }


    private UsbDeviceService.Listener listener = new UsbDeviceService.Listener() {
        @Override
        public void callBack(int code) {
            switch (code) {
                case MSG_NO_DEVICE:
                    speechHelper.speak("没有找到指定的指静脉设备");
                    break;
                case MSG_CONNECT_FAIL:
                    speechHelper.speak("连接指静脉设备失败");
                    break;
                case MSG_REQUEST_PERMISSION_FAIL:
                    speechHelper.speak("授权指静脉设备失败");
                    break;

            }

        }


    };

    private boolean isVeinDeviceopened() {
        return usbDeviceService.isVeiDeviceconnected();
    }


    private void speak(String msg) {
        speechHelper.speak(msg);
    }


    private void handleDetectFail(int code, MediatorLiveData<Integer> observer) {
        switch (code) {
            case XG_VOICE_PUTFINGER:
                speechHelper.speak("请放手指");
//                    speechHelper.PlayVoice(code, false);
                break;
            case XG_VOICE_PUTFINGER_AGAIN:
                speechHelper.speak("请再放一次");
//                    speechHelper.PlayVoice(code, false);
                break;
            case XG_VOICE_BEEP1:
            case XG_VOICE_BEEP2:
                speechHelper.PlayVoice(code, false);
//                    speechHelper.speak("请移开手指");
                break;
            case MSG_REGISTER_REPEAT:
                speechHelper.speak("此手指已登记", 800);
                observer.postValue(MSG_REGISTER_FAIL);
                break;
            case MSG_COLLECT_FAIL:
                //采集过程中没有放同一个手指，但是返回的错误提示不是期望的
                speechHelper.speak("采集失败");
                observer.postValue(MSG_REGISTER_FAIL);
                break;
            case XG_ERR_NO_SAME_FINGER:
                speechHelper.speak("请放同一根手指");
                break;
            case MSG_REGISTER_TIMEOUT:
                speechHelper.speak("登记超时");
    