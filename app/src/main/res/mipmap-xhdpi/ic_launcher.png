package com.nanj.zjh.bath.app;

import android.util.Log;

import androidx.annotation.Nullable;
import androidx.collection.ArrayMap;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MediatorLiveData;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.Observer;

import com.example.x6.serial.GridListener;
import com.example.x6.serial.LockerService;
import com.lxl.jzh.base.Utils.NetWorkUtil;
import com.lxl.jzh.locker.LockServiceProvider;
import com.nanj.zjh.bath.annotation.OperationCode;
import com.nanj.zjh.bath.api.ApiResponse;
import com.nanj.zjh.bath.api.NetWork;
import com.nanj.zjh.bath.api.PayService;
import com.nanj.zjh.bath.database.LockDataBase;
import com.nanj.zjh.bath.entity.Cabinet;
import com.nanj.zjh.bath.entity.OperationRecord;
import com.nanj.zjh.bath.entity.PayRequest;
import com.nanj.zjh.bath.entity.PayResult;
import com.nanj.zjh.bath.entity.QrCodeInfoResult;
import com.nanj.zjh.bath.utils.Constant;
import com.nanj.zjh.bath.utils.SpeechHelper;
import com.nanj.zjh.bath.utils.UsbDeviceService;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static com.example.x6.serial.LockerConstant.CABINET_CLOSED;
import static com.example.x6.serial.LockerConstant.CABINET_OPENED;
import static com.xgzx.veinmanager.VeinApi.MSG_COLLECT_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_CONNECT_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_ID_REPEAT;
import static com.xgzx.veinmanager.VeinApi.MSG_INVALID_ID;
import static com.xgzx.veinmanager.VeinApi.MSG_NO_DEVICE;
import static com.xgzx.veinmanager.VeinApi.MSG_REGISTER_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_REGISTER_REPEAT;
import static com.xgzx.veinmanager.VeinApi.MSG_REGISTER_TIMEOUT;
import static com.xgzx.veinmanager.VeinApi.MSG_REQUEST_PERMISSION_FAIL;
import static com.xgzx.veinmanager.VeinApi.MSG_VERTIFIY_FAIL;
import static com.xgzx.veinmanager.VeinApi.XG_ERR_NO_SAME_FINGER;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_BEEP1;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_BEEP2;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_PUTFINGER;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_PUTFINGER_AGAIN;
import static com.xgzx.veinmanager.VeinApi.XG_VOICE_VERIFY_FAIL;

public class HomeRepository {
    private static final String TAG = "HomeRepository";
    private LockerApp lockerApp;
    private PayService payService;
    private AppExecutors appExecutors;
    private LockDataBase dataBase;
    private UsbDeviceService usbDeviceService;
    private SpeechHelper speechHelper;
    private LockerService<Cabinet> lockerService;

    //    存储的时候获取可用的柜子
    private Cabinet availableCabinet;
    private OperationRecord operationRecord = OperationRecord.provide(Constant.ACTION_UNKNOWN);


    private AtomicBoolean started = new AtomicBoolean(false);

    public HomeRepository(AppExecutors appExecutors, LockDataBase dataBase) {
        lockerApp = LockerApp.get();
        this.appExecutors = appExecutors;
        this.dataBase = dataBase;

    }

    //    因为需要权限的处理 所以不能在构造函数中直接初始化
    public void start() {
        if (started.compareAndSet(false, true)) {

            lockerService = LockServiceProvider.get(gridListener, lockerApp);
            payService = NetWork.payService();

            speechHelper = new SpeechHelper(lockerApp);
            speechHelper.start();

            usbDeviceService = new UsbDeviceService(lockerApp, listener);
            usbDeviceService.connectVeinUsbDevice();
        }

    }

    private GridListener<Cabinet> gridListener = new GridListener<Cabinet>() {
        @Override
        public void updateStatus(Cabinet cabinet) {

        }
    };

    public void stop() {
        if (started.compareAndSet(true, false)) {
            speechHelper.release();
            speechHelper = null;

            usbDeviceService.close();
            usbDeviceService = null;
            lockerService.exit();
            lockerService = null;
        }
    }


    private UsbDeviceService.Listener listener = new UsbDeviceService.Listener() {
        @Override
        public void callBack(int code) {
            switch (code) {
                case MSG_NO_DEVICE:
                    speechHelper.speak("没有找到指定的指静脉设备");
                